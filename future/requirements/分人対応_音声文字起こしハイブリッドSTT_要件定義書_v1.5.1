# 分人対応 音声文字起こし（16時間セッション）ハイブリッドSTT 要件定義書

**作成日**: 2026-02-17  
**バージョン**: 1.5.1  
**ステータス**: ドラフト（実装方針確定版）  
**前版**: `【ARCHIVE】分人対応_音声文字起こしハイブリッドSTT_要件定義書_v1.5.0`

---

## 1. 本版で確定した方針

本版では、以下を確定事項として反映する。

1. **Local STT第一候補は Whisper 系**（実装候補: whisper.cpp）
2. **ターゲット端末は Google Pixel 9a をベンチマーク基準**とする
3. **Localモード時のサーバー送信はテキストのみ**（音声は送信しない）
4. 将来の保守性のため、**複数エンジン切替可能な構成**を採用する

---

## 2. 目的

v1.4.1の「Web SSOT + クラウドSTT」前提を拡張し、以下の2方式を同一プロダクトで扱えるようにする。

- **Server STTモード**: 既存どおりサーバーで文字起こし
- **Local STTモード**: 端末内（Whisper系）で文字起こし

主目的は、ユーザーがログイン後に方式を選択でき、どちらの方式でも同じ下流（蒸留/提案/週次）を利用できるアーキテクチャを確立すること。

---

## 3. スコープ

### 3.1 今回スコープ
- ログイン後方式選択UI（Server / Local）
- 選択結果の端末永続化
- 録音→セグメント→文字起こしへの mode 引き回し
- Localモード時の「テキストのみ送信」契約
- 方式別監査項目（selected/executed/fallback）定義
- Pixel 9a基準の性能目標・ベンチマーク観点定義
- 複数エンジン切替を想定した抽象化設計

### 3.2 スコープ外
- 全端末での最適化完了
- iOS向けローカルSTT本実装
- モデル配信基盤の最終版

---

## 4. 方式別アーキテクチャ

### 4.1 共通方針
- SSOTはテキスト+メタのみ
- セグメント単位で `transcribeMode` を持つ
- 下流処理は mode 非依存の共通パイプラインを利用

### 4.2 Server STTモード
1. 端末で録音セグメント生成
2. 音声をAPI送信
3. サーバーでSTT
4. テキスト保存
5. 音声削除

### 4.3 Local STTモード（確定）
1. 端末で録音セグメント生成
2. 端末内STT（Whisper系）でテキスト化
3. APIには **テキスト+最小メタのみ送信**
4. サーバーで共通パイプライン投入
5. 端末内音声はポリシーに従って削除

> Localモードでは、バックグラウンド長時間稼働を前提に、Webサーバーへ送るデータはテキストのみとする。

---

## 5. Local STTエンジン戦略

### 5.1 第一候補
- **Whisper系（whisper.cpp）**

### 5.2 エンジン切替可能な設計
- `TranscribeEngine` 抽象インターフェースを設ける
  - `WhisperEngine`（第一候補）
  - `ServerFallbackEngine`（既存互換）
  - 将来 `AltLocalEngine`（別エンジン）を追加可能
- `EngineResolver` が端末状態・設定に応じて実行エンジンを決定
- `selectedMode` と `executedMode` を分離して扱う

### 5.3 フォールバック
- Local選択時に以下でフォールバック可
  - モデル未配置
  - 推論失敗
  - タイムアウト
- フォールバック時は `fallbackReason` を必ず記録

---

## 6. Pixel 9a ベンチマーク基準

### 6.1 ベンチマーク対象
- 端末: **Google Pixel 9a**
- 音声長: 30秒 / 60秒 / 300秒
- 条件: 画面ON, 画面OFF(バックグラウンド), 充電中/非充電

### 6.2 合格基準（初期）
- 60秒音声のローカル文字起こし: **P95 20秒以内**
- 300秒音声のローカル文字起こし: **P95 90秒以内**
- 連続2時間運用でアプリクラッシュなし
- 熱制御で処理継続不能にならない
- バッテリー消費が実運用許容内（暫定しきい値は実測で最終化）

### 6.3 計測項目
- 推論時間（平均/P95）
- CPU使用率ピーク
- メモリ使用量ピーク
- 温度警告発生回数
- フォールバック率

---

## 7. データ契約

### 7.1 Segment共通フィールド
- `id`, `sessionId`, `segmentNo`
- `startAt`, `endAt`
- `text`
- `transcribeMode`（ユーザー選択）
- `executedMode`（実行方式）
- `sttStatus`
- `fallbackReason`（必要時）
- `localEngineVersion`（Local時）
- `sttProvider`（Server時）

### 7.2 API方針
- Serverモード: 既存 `/api/transcribe` 維持
- Localモード: テキスト送信エンドポイントを正式運用
- Localモードで音声送信は行わない

---

## 8. セキュリティ/プライバシー

- Localモード: 音声は端末処理を原則とし、サーバー非送信
- Serverモード: 既存の短期保持・削除ポリシーを維持
- 監査ログに mode 実行履歴を残し説明可能性を担保

---

## 9. 未確定事項（意思決定待ち）

以下はユーザー判断待ちとして残す。

1. **方式変更の適用単位**
   - 案A: 次セグメントから適用
   - 案B: セッション固定
2. **`selectedMode/executedMode/fallbackReason` の永続化レベル**
   - 案A: DB永続化（推奨）
   - 案B: ログのみ
3. **KPI比較の主軸**
   - 案A: 日次主軸
   - 案B: 週次主軸

---

## 10. 推奨案（提案）

意思決定待ち項目に対する実装側推奨は以下。

- 方式変更適用: **次セグメントから**（運用の分かりやすさと即時性のバランス）
- mode監査項目: **DB永続化必須**（後から品質・障害分析が可能）
- KPI主軸: **日次を主、週次を補助**（異常検知を早める）

---

## 11. 実装フェーズ

### Phase 1
- 方式選択UI/設定変更
- mode引き回し
- Local選択時フォールバック
- 監査ログ記録

### Phase 2
- Whisper系ローカル推論導入
- Pixel 9aベンチ測定
- executedMode/fallbackReason のDB反映

### Phase 3
- 複数エンジン切替機構を本格運用
- 端末状態に応じた自動切替最適化

